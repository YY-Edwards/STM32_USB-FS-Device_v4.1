总结STM32启动（这里只考虑从内部Flash启动）的大体过程:

1、上电复位，CPU从映射地址0x00000000（或原始地址0x08000000）处获取栈顶指针MSP（默认使用主堆栈，用于操作系统内核以及异常处理例程），
从0x00000004处获取程序计数器PC（复位向量）。

2、MSP指针必然指向SRAM区的，因为堆栈必须建立在该区。

3、根据PC的值找到复位中断处理函数Reset_Handler

4、调用SystemInit函数，基于不同时钟树的芯片初始化内部FALSH（IAP功能时需要重定位中断向量表），PLL并且更新系统时钟（v3.5以前的版本貌似需要手动调用此功能函数）。

5、调用__main函数:
	A.完成全局/静态变量的初始化工作（加载.data、.bss）：
		a.__scatterload_rt2函数:
			该函数的作用是设置四个寄存器为后续__scatterload_cpy()函数服务的。
			设置待copy内容（静态变量、全局变量）的加载域和运行域，设置待copy内容的大小，跳转进入__scatterload_cpy函数
		
		b.__scatterload_cpy函数
			完成静态变量、全局变量的值从flash到SRAM的加载以及程序的跳转进入__scatterload_zeroinit函数
		
		c.__scatterload_zeroinit函数
			未初始化的全局变量的初始化，跳转进入__user_steup_stackheap函数,实现堆栈的分配。
			
	B:初始化堆栈;
	C:库函数的初始化；
	D:程序跳转，进入main()函数。
	
6、调用main函数，进入C语言环境

注意1：当一个程序代码通过编译连接后，其全局、静态变量、堆栈的位置已经赋予了具体的内存地址（从0x200 0000开始）了。而局部变量只有在运行时才分配，
即位于堆栈中。

注意2：用户程序实际只能存储在Flash中，且能在Flash和SRAM中执行（因为cortex-m3核采用哈佛结构，代码可直接在Flash运行，
冯•诺依曼结构则必须将代码拷贝至RAM运行）。

注意3：
A.KEIL STM32 编译后FLASH ,RAM使用情况如下：
	Code：代码的大小
	RO：常量所占空间
	RW：程序中已经初始化的变量所占空间
	ZI：未初始化的static和全局变量以及堆栈所占的空间
	上述参数和芯片Flash以及SRAM的对应关系是 
	
	Flash占用大小=Code+RO+RW
	
	SRAM占用大小=RW+ZI
	
B.IAR中：
	
	Flash占用大小=RO_Code+RO_Data；flash中存储已初始化变量的值，存储方式貌似是特殊的算法。运行时，从flash拷贝到ram中。
	
	SRAM占用大小=RW_Data：编译完成后已初始化变量的地址内存空间已分配，具体不为零的值，需要等待运行时拷贝过来。
	
	
	
	
	
	
	